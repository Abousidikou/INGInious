#! /usr/bin/python
import json
import sys
import shutil
import os
import stat
import resource
import subprocess
from os.path import isfile, join
import inginious
from inginious import feedback
import time
import tempfile
import tarfile
import base64
import signal

def copytree(src, dst, symlinks=False, ignore=None):
    """ Custom copy tree to allow to copy into existing directories """
    for item in os.listdir(src):
        s = os.path.join(src, item)
        d = os.path.join(dst, item)
        if os.path.isdir(s):
            shutil.copytree(s, d, symlinks, ignore)
        else:
            shutil.copy2(s, d)

def setDirectoryRights(path):
    os.chmod(path, 0o777)
    os.chown(path, 4242, 4242)
    for root, dirs, files in os.walk(path):  
        for d in dirs:
            os.chmod(os.path.join(root, d), 0o777)
            os.chown(os.path.join(root, d), 4242, 4242)
        for f in files:
            os.chmod(os.path.join(root, f), 0o777)
            os.chown(os.path.join(root, f), 4242, 4242)
            
def setlimits():
    os.setgid(4242)
    os.setuid(4242)
    resource.setrlimit(resource.RLIMIT_CPU, (limits["time"], limits["time"]+5))
    resource.setrlimit(resource.RLIMIT_NPROC, (100, 100))
    
def setExecutable(filename):
    st = os.stat(filename)
    os.chmod(filename, st.st_mode | stat.S_IEXEC)

def executeProcess(filename,stdinString):
    setExecutable(filename)
    stdin = tempfile.TemporaryFile()
    stdin.write(stdinString)
    stdin.seek(0)
    
    stdout = tempfile.TemporaryFile()
    stderr = tempfile.TemporaryFile()
    p = subprocess.Popen([filename], preexec_fn=setlimits, stdin=stdin, stdout=stdout, stderr=stderr)
    start = time.time()
    while p.poll() is None:
        time.sleep(0.2)
        if time.time()-start > limits["time"]*2:
            p.kill()
            raise Exception("Timeout")
    stdout.seek(0)
    stderr.seek(0)
    
    status = p.returncode-128
    if status == signal.SIGXCPU:
        raise Exception("Timeout")
    
    return stdout.read(), stderr.read()

def b64tarfile(source_dir):
    encoded_string = ''
    
    with tarfile.open('/.__output/archive.tgz', "w:gz") as tar:
        tar.add(source_dir, arcname='/')
        
    with open('/.__output/archive.tgz', "rb") as tar:
        encoded_string = base64.b64encode(tar.read())
        
    return encoded_string

# Get input data
stdin = sys.stdin.read().strip('\0').strip()
data = json.loads(stdin)
input_data = data["input"]
limits = data["limits"]

# Create output directory
os.mkdir("/.__output")

#Copy /ro/task (which is read-only) in /task. Everything will be executed there
shutil.copytree("/ro/task","/task")

#Set rights on some files
setDirectoryRights("/tmp")
setDirectoryRights("/task")
setDirectoryRights("/.__output")

#Launch everything
stdout = '{}'
stderr = '{}'
if os.path.exists("/task/run"):
    os.chdir("/task")
    try:
        stdout, stderr = executeProcess("/task/run", input_data['student_response']+'\n')
    except:
        print json.dumps({"result":"timeout","text":"'/task/run' did a timeout\n" + stdout,"problems":{}})
        exit()
else:
    print json.dumps({"result":"crash","text":"'/task/run' couldn't be found","problems":{}})
    exit()

# Copy required files in output folder
for filepath in ['/tmp/work/new_file.oz', '/tmp/work/new_file.ozf', '/tmp/work/errC.txt', '/tmp/work/out.txt', '/tmp/work/out.txt']:
    if os.path.exists(filepath):
        shutil.copy(filepath, '/.__output')

# Produce feedback
feedback = json.loads(stdout)
if not feedback:
    print json.dumps({"result":"crash", "text":"No feedback was given !", "problems":{}})
    exit()
else:
    feedback['result'] = 'success' if feedback['correct'] else 'failed'
    del feedback['correct']
    del feedback['score']
    feedback['text'] = feedback.pop('msg')
    feedback['archive'] = b64tarfile('/.__output')
    print json.dumps(feedback)
