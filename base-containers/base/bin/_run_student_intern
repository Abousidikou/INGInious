#! /bin/python3.6 
# -*- coding: utf-8 -*-
#
# This file is part of INGInious. See the LICENSE and the COPYRIGHTS files for
# more information about the licensing of this file.
import os
import shlex
import socket
import subprocess
import threading
import msgpack
import array
import struct
import sys
from inginious_container_api.utils import set_limits_user, start_ssh_server, ssh_wait
import asyncio
import zmq.asyncio
import time
import logging
import errno

######################################################################
######################################################################
########### HELPERS ##################################################
######################################################################
######################################################################

def setup_logger():
    logger = logging.getLogger("inginious-student")
    logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    ch.setFormatter(formatter)
    logger.addHandler(ch)
    return logger


def check_runtimes(runtime, parent_runtime):
    """ Check information about the runtime
    outputs:
    shared_kernel: set to True if the current container is not on Kata runtime
    dual_dockers: set to True if both grading_container and the current student_container are using docker runtime
    """
    if runtime != "kata-runtime":
        shared_kernel = True
        os.mkdir("/.__input")
        shared_kernel_file = open("/.__input/__shared_kernel", "w")
        shared_kernel_file.close()
    else:
        shared_kernel = False
    dual_dockers = shared_kernel and parent_runtime != "kata"
    return shared_kernel, dual_dockers


def receive_initial_command(both_dockers):
    """ Receive the command to run (directly from student-grading socket if both dockers or via the agent otherwise)"""
    if both_dockers:  # Grading and student containers are both on docker
        # Connect to the socket
        com_module = socket.socket(socket.AF_UNIX)  # , socket.SOCK_CLOEXEC) # for linux only
        com_module.connect("/__parent.sock")
        # Say hello
        print("Saying hello")
        com_module.send(b'H')
        print("Said hello")
        # Receive fds
        print("Receiving fds")
        msg, fds = recv_fds(com_module, 1, 3)
        assert msg == b'S'
        print("Received fds")
        # Unpack the start message
        print("Unpacking start cmd")
        unpacker = msgpack.Unpacker()
        start_cmd = None
        while start_cmd is None:
            s = com_module.recv(1)
            unpacker.feed(s)
            for obj in unpacker:
                return com_module, fds, obj
    else:  # Grading or student container is on Kata
        msg = event_loop.run_until_complete(receive_initial_message(container_stdin))
        return None, None, msg


async def receive_initial_message(reader: asyncio.StreamReader):
    """ Get the initial command message from the agent.
     Used only when both containers are not on a shared-kernel """
    buf = bytearray()
    logger.info("waiting for agent initial message...")
    while len(buf) != 4 and not reader.at_eof():
        buf += await reader.read(4 - len(buf))
    length = struct.unpack('!I', bytes(buf))[0]
    buf = bytearray()
    while len(buf) != length and not reader.at_eof():
        buf += await reader.read(length - len(buf))
    message = msgpack.unpackb(bytes(buf), use_list=False)  # EXCEPTION EXTRA DATA
    logger.info("initial message received !")
    logger.info(message)
    return message


def recv_fds(sock, msglen, maxfds):
    """ Receive FDs from the unix socket. Copy-pasted from the Python doc.
    Used only if both grading and student containers are using docker runtime"""
    fds = array.array("i")  # Array of ints
    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))
    for cmsg_level, cmsg_type, cmsg_data in ancdata:
        if (cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS):
            # Append data, ignoring any truncated integers at the end.
            fds.fromstring(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])
    return msg, list(fds)


async def stdio():
    """ Create the stdin and stdout streams to communicate with the agent """
    my_loop = asyncio.get_event_loop()
    reader = asyncio.StreamReader()
    reader_protocol = asyncio.StreamReaderProtocol(reader)
    writer_transport, writer_protocol = await my_loop.connect_write_pipe(asyncio.streams.FlowControlMixin, os.fdopen(1, 'wb'))
    writer = asyncio.StreamWriter(writer_transport, writer_protocol, None, my_loop)
    await my_loop.connect_read_pipe(lambda: reader_protocol, sys.stdin)
    return reader, writer


async def handle_stdin(reader: asyncio.StreamReader, proc_input):
    """ Deamon to handle messages from the agent.
    Used only when both containers are not on a shared kernel"""
    try:
        while not reader.at_eof():
            buf = bytearray()
            logger.info("waiting for agent message...")
            while len(buf) != 4 and not reader.at_eof():
                buf += await reader.read(4 - len(buf))
            if reader.at_eof():
                continue
            length = struct.unpack('!I', bytes(buf))[0]
            buf = bytearray()
            while len(buf) != length and not reader.at_eof():
                buf += await reader.read(length - len(buf))
            if reader.at_eof():
                continue
            message = msgpack.unpackb(bytes(buf), use_list=False)  # EXCEPTION EXTRA DATA
            logger.info("message received !")
            logger.info(message)
            status = handle_stdin_message(message, proc_input)
            if status == "pipe_closed":
                return
    except (asyncio.CancelledError, KeyboardInterrupt):
        return
    except Exception as e:
        logger.info("Exception occured during handle_stdin")
        logger.info(e)
        return


def handle_stdin_message(msg, proc_input):
    """ Process a single message from the agent (stdin message for the student code process or signals messages).
    Used only when both containers are not on a shared kernel """
    try:
        if msg["type"] == "stdin":
            input = msg["message"] + '\n'
            proc_input.write(input.encode("utf8"))
            proc_input.flush()
            return "ok"
        if msg["type"] == "student_signal":
            signal = msg["signal_data"]
            p.send_signal(int(signal.decode('utf8')))
    except IOError as e:
        if e.errno == errno.EPIPE:
            return "pipe_closed"

    except Exception as e:
        logger.info("Error in handle_stdin_message")


def handle_outputs_helper(output, socket_id, type, lock):
    """ Simple helper to launch the handle_outputs function in its own thread using its own asyncio loop.
    Used only when both containers are not on a shared kernel """
    loop = asyncio.new_event_loop()
    loop.run_until_complete(handle_outputs(output, socket_id, type, lock))
    loop.close()
    if type == "stdout":  # when the handle_output thread finishes, it stop the loop (to stop the handle_stin task)
        event_loop.call_soon_threadsafe(event_loop.stop)


async def handle_outputs(output, socket_id, type, lock):
    """ Handle a specific output from the student code process (stdout or stderr) and send it to the grading container via the agent
    Used only when both containers are not on a shared kernel """
    try:
        for line in output:
            message = {"type": type, "socket_id": socket_id, "message": line.rstrip().decode("utf-8")}
            if type == "stdout":
                time.sleep(0.001)  # Allow stderr messages to be sent slightly before stdout messages (arbitrary decision to avoid non-deterministic message order)
            lock.acquire()
            await write_stdout(message)
            lock.release()
            logger.info("Sending output: ")
            logger.info(line.rstrip().decode("utf-8"))
        logger.info("handle_outputs " + type + "finished")
    except Exception as e:
        logger.info("error in handle_outputs")
        logger.info(e)


def handle_signals(subprocess, socket):
    """ Handles signals given by run_student on the socket.
    Used only when both containres are on a shared kernel. Otherwise, it is already handled by handle_stdin function """
    while True:
        try:
            signal = socket.recv(3)
            if signal == b'---' or len(signal) < 3:  # quit
                return
            subprocess.send_signal(int(signal.decode('utf8')))
        except:
            exit()


def run_teardown_script():
    """ Run the teardown script. Only used when a teardown script was specified """
    p3 = subprocess.Popen(shlex.split(start_cmd["teardown_script"]), preexec_fn=set_limits)
    p3.wait()  # Wait for teardown_script to finish before exiting the container


def handle_ssh_session(container_id, both_dockers):
    """ Start the ssh server and send identification information """
    ssh_user, password = start_ssh_server(user)
    if both_dockers:
        # Send ssh information to the grading container
        message = msgpack.dumps({"type": "ssh_student", "ssh_user": ssh_user, "password": password})  # constant size
        message_size = struct.pack('!I', len(message))
        socket_unix.send(message_size)
        socket_unix.send(message)
    else:
        # Send ssh information directly to the agent
        msg = {"type": "ssh_student", "ssh_user": ssh_user, "ssh_key": password,
               "container_id": container_id}
        event_loop.run_until_complete(write_stdout(msg))
    # Wait for user to connect and leave
    ssh_retval = ssh_wait(ssh_user)
    return ssh_retval


async def write_stdout(msg):
    """ Helper to send messages to the agent on the container stdout stream """
    msg = msgpack.dumps(msg, use_bin_type=True)
    container_stdout.write(struct.pack('!I', len(msg)))
    container_stdout.write(msg)
    await container_stdout.drain()

######################################################################
######################################################################
########### BODY #####################################################
######################################################################
######################################################################

# Setup the logger (for debug purpose)
logger = setup_logger()

# Check the runtimes
runtime = sys.argv[1]
parent_runtime = sys.argv[2]
shared_kernel, only_dockers = check_runtimes(runtime, parent_runtime)

# Setup the asyncio loop and container_stdin/stdout streams for communications with agent when both containers are not on a shared kernel
if not only_dockers:
    context = zmq.asyncio.Context()
    event_loop = zmq.asyncio.ZMQEventLoop()
    asyncio.set_event_loop(event_loop)
    container_stdin, container_stdout = event_loop.run_until_complete(stdio())

# Get the command to be run
socket_unix, fds, start_cmd = receive_initial_command(only_dockers)

# Check security
student_container_id = start_cmd["student_container_id"]
user = start_cmd["user"]  # Know if you are worker (on docker) or root (on Kata)
if user == "root" and shared_kernel:
    #print("You can not run as root on docker runtime")
    exit(251)

# Add some elements to /etc/hosts and /etc/resolv.conf if needed
system_files = {"hosts": ("/etc/hosts", True), "resolv.conf": ("/etc/resolv.conf", False)}
for name, (spath, append) in system_files.items():
    if os.path.exists(os.path.join('/task/systemfiles/', name)):
        try:
            open(spath, 'ab' if append else 'wb').write(b'\n' + open(os.path.join('/task/systemfiles/', name), 'rb').read())
        except IOError:
            exit(254)

# Start the process
os.chdir(start_cmd["working_dir"])
set_limits = lambda: set_limits_user(user)  # To know if the command should be executed as root or worker
if start_cmd["command"] is None or start_cmd["command"] == "":  # Avoid to run an empty command
    start_cmd["command"] = "echo 'info: student container started with no command set' "

# Run the student code in its own subprocess and handle inputs/outputs
if only_dockers:
    p = subprocess.Popen(shlex.split(start_cmd["command"]), preexec_fn=set_limits, stdin=fds[0], stdout=fds[1],
                         stderr=fds[2])
    signal_thread = threading.Thread(target=lambda: handle_signals(p, socket_unix), daemon=True)
    signal_thread.start()
    retval = p.wait()
else:
    p = subprocess.Popen(shlex.split(start_cmd["command"]), preexec_fn=set_limits, stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    write_lock = threading.Lock()  # Lock to avoid stdout_handler and stderr_handler to write on the stdout_stream at the same time
    stdout_handler = threading.Thread(target=handle_outputs_helper, args=(p.stdout, start_cmd["socket_id"], "stdout", write_lock))
    stderr_handler = threading.Thread(target=handle_outputs_helper, args=(p.stderr, start_cmd["socket_id"], "stderr", write_lock))
    stdout_handler.start()
    stderr_handler.start()
    try:
        event_loop.run_until_complete(handle_stdin(container_stdin, p.stdin))
    except RuntimeError as e:
        if e == 'Event loop stopped before Future completed.':  # The loop will be stopped by stdout_handler
            logger.info("student code finished !")
    retval = p.wait()
    stdout_handler.join()
    stderr_handler.join()

# Handle SSH
if start_cmd["ssh"]:
    retval = handle_ssh_session(student_container_id, only_dockers)

# Run teardown script
if start_cmd["teardown_script"]:
    run_teardown_script()
exit(retval)