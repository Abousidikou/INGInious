#! /bin/python3.6
# -*- coding: utf-8 -*-
#
# This file is part of INGInious. See the LICENSE and the COPYRIGHTS files for
# more information about the licensing of this file.
import os
import shlex
import socket
import subprocess
import threading
import msgpack
import array
import struct
import sys
from inginious_container_api.utils import set_limits_user, start_ssh_server, ssh_wait
import asyncio
import zmq
import zmq.asyncio


######################################################################
######################################################################
########### HELPERS ##################################################
######################################################################
######################################################################

def check_runtimes(runtime, parent_runtime):
    if runtime != "kata-runtime":
        shared_kernel = True
        os.mkdir("/.__input")
        shared_kernel_file = open("/.__input/__shared_kernel", "w")
        shared_kernel_file.close()
    else:
        shared_kernel = False
    return shared_kernel, shared_kernel and parent_runtime != "kata"


def receive_initial_command(both_dockers):
    if both_dockers:  # Grading and student containers are both on docker
        # Connect to the socket
        client = socket.socket(socket.AF_UNIX)  # , socket.SOCK_CLOEXEC) # for linux only
        client.connect("/__parent.sock")
        # Say hello
        print("Saying hello")
        client.send(b'H')
        print("Said hello")
        # Receive fds
        print("Receiving fds")
        msg, fds = recv_fds(client, 1, 3)
        assert msg == b'S'
        print("Received fds")
        # Unpack the start message
        print("Unpacking start cmd")
        unpacker = msgpack.Unpacker()
        start_cmd = None
        while start_cmd is None:
            s = client.recv(1)
            unpacker.feed(s)
            for obj in unpacker:
                return client, fds, obj
    else:  # Grading or student container is on Kata
        loop = zmq.asyncio.ZMQEventLoop()
        asyncio.set_event_loop(loop)
        msg = loop.run_until_complete(receive_command_helper())
        return None, None, msg


def recv_fds(sock, msglen, maxfds):
    """ Receive FDs from the unix socket. Copy-pasted from the Python doc """
    fds = array.array("i")  # Array of ints
    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))
    for cmsg_level, cmsg_type, cmsg_data in ancdata:
        if (cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS):
            # Append data, ignoring any truncated integers at the end.
            fds.fromstring(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])
    return msg, list(fds)


async def receive_command_helper():
    stdin_sr, stdout = await stdio()
    command = await receive_command(stdin_sr)
    return command


async def receive_command(reader):
    try:
        buf = bytearray()
        while len(buf) != 4 and not reader.at_eof():
            buf += await reader.read(4 - len(buf))
        length = struct.unpack('!I', bytes(buf))[0]
        buf = bytearray()
        while len(buf) != length and not reader.at_eof():
            buf += await reader.read(length - len(buf))
        stdin_message = msgpack.unpackb(bytes(buf), use_list=False)
        return stdin_message
    except (asyncio.CancelledError, KeyboardInterrupt):
        print("handle_stdin crashed !")
        return


async def stdio():
    my_loop = asyncio.get_event_loop()
    reader = asyncio.StreamReader()
    reader_protocol = asyncio.StreamReaderProtocol(reader)
    writer_transport, writer_protocol = await my_loop.connect_write_pipe(asyncio.streams.FlowControlMixin, os.fdopen(1, 'wb'))
    writer = asyncio.StreamWriter(writer_transport, writer_protocol, None, my_loop)
    await my_loop.connect_read_pipe(lambda: reader_protocol, sys.stdin)
    return reader, writer






######################################################################
######################################################################
########### BODY #####################################################
######################################################################
######################################################################

# Check the runtimes ######################################
runtime = sys.argv[1]
parent_runtime = sys.argv[2]
shared_kernel, only_dockers = check_runtimes(runtime, parent_runtime)

# Get the command to be run ##################################
client, fds, start_cmd = receive_initial_command(only_dockers)






